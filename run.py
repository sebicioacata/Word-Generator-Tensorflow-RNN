# encoding: UTF-8
# Copyright 2017 Google.com
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import tensorflow as tf
import numpy as np
import process_inputs as proc
import hyper_params as hyper

alpha_size = hyper.ALPHA_SIZE
n_layers = hyper.N_LAYERS
inner_size = hyper.INNER_SIZE

eminescu = "checkpoints/rnn_train_1521378856-7290000"

checkpoint = eminescu    # Use topn=10 for all but the last one which works with topn=2 for Shakespeare and topn=3 for Python

ncnt = 0
with tf.Session() as sess:
    
    new_saver = tf.train.import_meta_graph(checkpoint + '.meta')

    new_saver.restore(sess, checkpoint)
    
    x = proc.encode_char("A")
    x = np.array([[x]])    # Shape [batch_size, seq_len] with batch_size=1 and seq_len=1

    # Init
    y = x
    h = np.zeros([1, inner_size * n_layers], dtype=np.float32)    # [ batch_size, inner_size * n_layers]
    file = open("generated_output.txt", "w")
    file.write("This is a poem in the style of Mihai Eminescu, generated by a recurrent neural net \o/\o/  \n\n")
    
    for _ in range(10000):
        
        yo, h = sess.run(['Yo:0', 'H_final:0'], feed_dict={'X:0': y, 'p_keep:0': 1., 'H_init:0': h, 'batch_size_:0': 1})

        # If sampling is be done from the topn most likely characters, the generated text
        # is more credible and more "english". If topn is not set, it defaults to the full
        # distribution (ALPHASIZE)

        # Recommended: topn = 10 for intermediate checkpoints, topn=2 or 3 for fully trained checkpoints
        c = proc.sample_from_probabilities(yo, topn=2)
        
        y = np.array([[c]])    # shape [batch_size, seq_len] with batch_size=1 and seq_len=1
        
        c = chr(proc.decode_char(c))
        
        print(c, end="")
        file.write(c)

        if c == '\n':
            ncnt = 0
        else:
            ncnt += 1
        if ncnt == 40:
            print("")
            file.write("")
            ncnt = 0
            
    file.close() 
